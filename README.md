# ConstructorOCA4
Создание Конструкторов
Как вы узнали из главы 1, конструктор - это специальный метод, который соответствует имени класса и не имеет возвращаемого типа. Вот пример:
public class Bunny { 
 public Bunny() {  
  System.out.println("constructor"); 
 }}
Имя конструктора, Bunnyсоответствует названию класса Bunny, и нет никакого возвращаемого типа, даже void. Это делает это конструктором.
Можете ли вы сказать, почему эти два не являются допустимыми конструкторами для Bunnyкласса?

public class Bunny { 
 public Bunny() {    System.out.println("constructor");
  }}

Первый не соответствует имени класса, потому что Java чувствительна к регистру. Поскольку он не совпадает,
Java знает, что он не может быть конструктором и должен быть обычным методом. Тем не менее, он пропускает тип возвращаемого значения и не компилируется. 
Второй метод - очень хороший метод, но не конструктор, потому что он имеет возвращаемый тип.
Конструкторы используются при создании нового объекта. Этот процесс называется созданием экземпляра, потому что он создает новый экземпляр класса.
Когда мы пишем, вызывается конструктор, new за которым следует имя класса, который мы хотим создать. Например:
new Bunny()
Когда Java видит newключевое слово, оно выделяет память для нового объекта. Java также ищет конструктор и вызывает его.
Конструктор обычно используется для инициализации переменных экземпляра. thisКлючевое слово говорит Java вы хотите ссылаться на переменном экземпляр.
Большую часть времени не thisявляется обязательным. Проблема в том, что иногда есть две переменные с одинаковыми именами.
В конструкторе один является параметром, а другой - переменной экземпляра. Если вы не говорите иначе, Java дает вам наиболее детальную область видимости, 
которая является параметром. Использование this.nameговорит Java, что вы хотите переменную экземпляра.
Вот общий способ написания конструктора:


1: public class Bunny
2:   private String color;
3:   public Bunny(String color) {
4:     this.color = color;
5:  } }

В строке 4 мы присваиваем параметр colorпеременной экземпляра color. Правая часть назначения относится к параметру, потому что мы не указываем ничего особенного.
Левая часть назначения использует thisJava, чтобы указать, что мы хотим использовать переменную экземпляра.
Теперь давайте посмотрим на некоторые примеры, которые не являются общими, но которые вы можете увидеть на экзамене:

1: public class Bunny {
2:   private String color;
3:   private int height;
4:   private int length;
5:   public Bunny(int length, int theHeight) {
6:     length = this.length;     // backwards – no good!
7:     height = theHeight;          // fine because a different name
8:     this.color = "white";     // fine, but redundant
9:   }
10: public static void main(String[] args) {
11:  Bunny b = new Bunny(1, 2);
12:  System.out.println(b.length + " " + b.height + " " + b.color);
13:  } }
Строка 6 неверна, и вы должны следить за ней на экзамене. Переменная экземпляра lengthначинается со значения 0. Это 0 присваивается параметру метода length.
Переменная экземпляра остается на 0. Строка 7 является более простой. Параметр theHeightи переменная экземпляра heightимеют разные имена.
Поскольку нет конфликта имен, thisне требуется. Наконец, строка 8 показывает, что ее разрешено использовать, thisдаже если нет дублирования имен переменных.
В этом разделе мы рассмотрим конструкторы по умолчанию, конструкторы с перегрузкой, конечные поля и порядок инициализации в классе.
Конструктор по умолчанию
У каждого класса в Java есть конструктор, независимо от того, кодируете вы его или нет. Если вы не включите в класс никаких конструкторов,
Java создаст их без каких-либо параметров. Этот созданный Java конструктор называется конструктором по умолчанию .
Иногда мы называем это конструктором по умолчанию без аргументов для ясности. Вот пример:

public class Rabbit { 
 public static void main(String[] args) {    
Rabbit rabbit = new Rabbit();          // Calls default constructor
  }}
В Rabbitклассе Java видит, что конструктор не был закодирован, и создает его. Этот конструктор по умолчанию эквивалентен вводу этого:

public Rabbit() {}

Конструктор по умолчанию имеет пустой список параметров и пустое тело. Это хорошо для вас, чтобы напечатать это в себе. Тем не менее, поскольку он ничего не делает,
Java с радостью предоставит его для вас и сэкономит при печати.
Мы продолжаем говорить, генерируется . Это происходит на этапе компиляции. Если вы посмотрите на файл с .javaрасширением, конструктор все равно будет отсутствовать.
Только в скомпилированном файле с .classрасширением он появляется.
Помните, что конструктор по умолчанию предоставляется только при отсутствии конструкторов. Какой из этих классов, по вашему мнению, имеет конструктор по умолчанию?

class Rabbit1 {}
class Rabbit2 {
  public Rabbit2() { }}
class Rabbit3 {  
public Rabbit3(boolean b) { }}
class Rabbit4 {  
private Rabbit4() { }}
Только Rabbit1получает конструктор по умолчанию без аргументов. У него нет закодированного конструктора, поэтому Java генерирует конструктор по умолчанию без аргументов.
Rabbit2и у Rabbit3обоих уже есть публичные конструкторы. Rabbit4имеет частный конструктор.
Поскольку для этих трех классов определен конструктор, конструктор по умолчанию без аргументов для вас не вставляется.
Давайте кратко рассмотрим, как вызывать эти конструкторы:


1: public class RabbitsMultiply {
2:   public static void main(String[] args) {
3:    Rabbit1 r1 = new Rabbit1();
4:    Rabbit2 r2 = new Rabbit2();
5:    Rabbit3 r3 = new Rabbit3(true);
6:    Rabbit4 r4 = new Rabbit4(); // DOES NOT COMPILE
7:   } }

Строка 3 вызывает созданный конструктор по умолчанию без аргументов. Строки 4 и 5 вызывают предоставленные пользователем конструкторы.
Строка 6 не компилируется. Rabbit4сделал конструктор закрытым, чтобы другие классы не могли его вызвать.
Наличие частного конструктора в классе говорит компилятору не предоставлять конструктор по умолчанию без аргументов.
Это также не позволяет другим классам создавать экземпляры класса. 
Это полезно, когда класс имеет только статические методы или класс хочет контролировать все вызовы для создания новых экземпляров самого себя.
Перегрузка
 КонструкторовДо сих пор вы видели только один конструктор на класс. Вы можете иметь несколько конструкторов в одном классе, если они имеют разные сигнатуры методов.
 При перегрузке методов имя метода и список параметров должны совпадать. У конструкторов имя всегда одинаково, поскольку оно должно совпадать с именем класса.
 Это означает, что конструкторы должны иметь разные параметры, чтобы быть перегруженными.
Этот пример показывает два конструктора:
public class Hamster {  
private String color; 
 private int weight;  
public Hamster(int weight) {               // first constructor 
   this.weight = weight;  
  color = "brown";
  }
  public Hamster(int weight, String color) {     // second constructor 
  this.weight = weight;  
 this.color = color; 
 }}
Один из конструкторов принимает один intпараметр. Другой берет intи String. Эти списки параметров различны, поэтому конструкторы успешно перегружены.
Здесь есть проблема. Есть немного дублирования. В программировании даже небольшое дублирование имеет тенденцию превращаться в большое дублирование, 
поскольку мы постоянно добавляем «еще одну вещь». Что нам действительно нужно, так это чтобы первый конструктор вызывал второй конструктор с двумя параметрами.
Вы могли бы испытать желание написать это:

public Hamster(int weight) { 
 Hamster(weight, "brown");     // DOES NOT COMPILE}
Так не пойдет. Конструкторы могут быть вызваны только записью newперед именем конструктора. Они не похожи на обычные методы, которые вы можете просто вызвать. 
Что произойдет, если мы вставим newперед именем конструктора?

public Hamster(int weight) { 
 new Hamster(weight, "brown");     // Compiles but does not do what we want}
Эта попытка компилируется. Это не делает то, что мы хотим, хотя. Когда вызывается конструктор с одним параметром, он создает объект по умолчанию weightи color.
Затем он создает другой объект с желаемым weightи colorи игнорирует новый объект. Это не то, что мы хотим. Мы хотим weightи colorустанавливаем объект, 
который пытаемся создать в первую очередь.
Java предоставляет решение: thisда, то же самое ключевое слово, которое мы использовали для ссылки на переменные экземпляра. Когда thisиспользуется,
как если бы это был метод, Java вызывает другой конструктор в том же экземпляре класса.

public Hamster(int weight) {  
this(weight, "brown");
}
Успех! Теперь Java вызывает конструктор, который принимает два параметра. weightи colorполучить на этом экземпляре.
this()есть одно особое правило, которое вам нужно знать. Если вы решили вызвать его, this()вызов должен быть первым некомментированным оператором в конструкторе.

3: public Hamster(int weight) {
4:   System.out.println("in constructor");
5:   // ready to call this
6:   this(weight, "brown");     // DOES NOT COMPILE
7: }
Хотя оператор print в строке 4 не меняет никаких переменных, он все равно является оператором Java и не может быть вставлен перед вызовом this().
Комментарий в строке 5 просто отлично. Комментарии не запускают операторы Java и разрешены где угодно.
Конструктор цепочки
Перегруженные конструкторы часто вызывают друг друга. Один из распространенных приемов - каждый конструктор добавляет один параметр, 
пока не доберется до конструктора, который выполняет всю работу. Этот подход называется конструированием цепочки . В этом примере все три конструктора связаны между собой.

public class Mouse {  
 private int numTeeth;  
 private int numWhiskers; 
  private int weight;  
 public Mouse(int weight) {    
 this(weight, 16); // calls constructor with 2 parameters  
 }   
public Mouse(int weight, int numTeeth) {  
  this(weight, numTeeth, 6); // calls constructor with 3 parameters
   } 
  public Mouse(int weight, int numTeeth, int numWhiskers) {  
   this.weight = weight;   
  this.numTeeth = numTeeth;  
   this.numWhiskers = numWhiskers;  
 }  
 public void print() {  
   System.out.println(weight + " " + numTeeth + " " + numWhiskers); 
  } 
  public static void main(String[] args) {     
Mouse mouse = new Mouse(15);  
   mouse.print();  
 }}

Этот код печатается 15 16 6. main()Метод вызывает конструктор с одним параметром.
Этот конструктор добавляет второе жестко закодированное значение и вызывает конструктор с двумя параметрами. Этот конструктор добавляет еще одно жестко закодированное значение и вызывает конструктор с тремя параметрами. Трехпараметрический конструктор назначает переменные экземпляра.
